{{- if .Values.applications.prometheus.enabled }}
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: {{ .Values.applications.prometheus.name }}
  namespace: argocd
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    repoURL: {{ .Values.applications.prometheus.repo }}
    chart: {{ .Values.applications.prometheus.chart }}
    targetRevision: {{ .Values.applications.prometheus.targetRevision }}
    helm:
      # CRDs are too large for client-side apply (annotation limit 256KB). Install them once with server-side apply (see scripts/install-prometheus-crds.ps1).
      skipCrds: true
      values: |
        fullnameOverride: prometheus
        prometheusOperator:
          enabled: true
          # Avoid TLS handshake errors blocking reconciliation (webhook cert issues in some environments)
          admissionWebhooks:
            enabled: false
          # Run operator on any pool (no nodeSelector) so it schedules even if monitoring pool is full
          resources:
            limits: { cpu: 200m, memory: 256Mi }
            requests: { cpu: 100m, memory: 128Mi }
        prometheus:
          enabled: true
          prometheusSpec:
            replicas: 1
            retention: 7d
            retentionSize: 15GB
            nodeSelector:
              cloud.google.com/gke-nodepool: {{ .Values.global.nodePools.monitoring }}
            tolerations:
              - key: node-pool
                operator: Equal
                value: monitoring
                effect: NoSchedule
            resources:
              limits: { cpu: 2000m, memory: 4Gi }
              requests: { cpu: 1000m, memory: 2Gi }
            storageSpec:
              volumeClaimTemplate:
                spec:
                  storageClassName: standard-rwo
                  accessModes: [ReadWriteOnce]
                  resources:
                    requests:
                      storage: 20Gi
            serviceMonitorSelector: {}
            serviceMonitorNamespaceSelector: {}
            podMonitorSelector: {}
            podMonitorNamespaceSelector: {}
            ruleSelector: {}
            ruleNamespaceSelector: {}
            scrapeInterval: 30s
            evaluationInterval: 30s
        alertmanager:
          enabled: true
          alertmanagerSpec:
            replicas: 1
            nodeSelector:
              cloud.google.com/gke-nodepool: {{ .Values.global.nodePools.monitoring }}
            tolerations:
              - key: node-pool
                operator: Equal
                value: monitoring
                effect: NoSchedule
            resources:
              limits: { cpu: 500m, memory: 512Mi }
              requests: { cpu: 250m, memory: 256Mi }
            storage:
              volumeClaimTemplate:
                spec:
                  storageClassName: standard-rwo
                  accessModes: [ReadWriteOnce]
                  resources:
                    requests:
                      storage: 5Gi
            config:
              global:
                resolve_timeout: 5m
              route:
                group_by: [alertname]
                group_wait: 10s
                group_interval: 10s
                repeat_interval: 12h
                receiver: slack
                routes:
                  - match: { severity: critical }
                    receiver: slack
                {{- if .Values.applications.prometheus.alertmanagerDiscordWebhookUrl }}
                  - match: { severity: critical }
                    receiver: discord
                {{- end }}
              receivers:
                - name: null
                - name: slack
                  slack_configs:
                    - send_resolved: true
                      api_url: {{ .Values.applications.prometheus.alertmanagerWebhookUrl | default "https://hooks.slack.com/services/REPLACE/WITH/YOUR_WEBHOOK" | quote }}
                      channel: "#alerts"
                {{- if .Values.applications.prometheus.alertmanagerDiscordWebhookUrl }}
                - name: discord
                  webhook_configs:
                    - url: {{ .Values.applications.prometheus.alertmanagerDiscordWebhookUrl | quote }}
                      send_resolved: true
                {{- end }}
        grafana:
          enabled: false
        kubeStateMetrics:
          enabled: true
        nodeExporter:
          enabled: true
        defaultRules:
          create: true
          rules:
            alertmanager: true
            etcd: false
            general: true
            k8s: true
            kubeApiserver: true
            kubeApiserverAvailability: true
            kubeApiserverError: true
            kubeApiserverSlos: true
            kubelet: true
            kubeProxy: true
            kubePrometheusGeneral: true
            kubePrometheusNodeRecording: true
            kubernetesApps: true
            kubernetesResources: true
            kubernetesStorage: true
            kubernetesSystem: true
            kubeScheduler: true
            kubeStateMetrics: true
            network: true
            node: true
            nodeExporterAlerting: true
            nodeExporterRecording: true
            prometheus: true
            prometheusOperator: true
            time: true
  destination:
    server: https://kubernetes.default.svc
    namespace: {{ .Values.applications.prometheus.namespace }}
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
      # Avoid CRD "metadata.annotations: Too long (max 262144 bytes)" - use server-side apply
      - ServerSideApply=true
{{- end }}
